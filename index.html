<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Safe Turn</title>
<link rel="manifest" href="./manifest.json"/>
<meta name="theme-color" content="#141414"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  :root{ --accent:#3498db; --muted:#666; }
  html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial;background:#000;color:#fff}
  /* Fullscreen map */
  #map{position:fixed;inset:0;width:100%;height:100vh;z-index:0}
  /* App title top-left */
  #appTitle{
    position:fixed; top:10px; left:12px; z-index:4300;
    background:rgba(0,0,0,0.55); padding:6px 10px; border-radius:6px;
    font-size:16px; color:#fff; font-weight:700; backdrop-filter: blur(4px);
    pointer-events:none;
  }
  /* Compact collapsible menu (right interior) */
  .menu-wrapper{
    position:fixed; right:12px; bottom:18px; z-index:4500; display:flex; flex-direction:column; align-items:flex-end;
  }
  .menu-handle{
    width:54px; height:54px; border-radius:28px; background:var(--accent); color:#fff;
    display:flex; align-items:center; justify-content:center; font-weight:700; cursor:pointer;
    box-shadow:0 6px 18px rgba(0,0,0,0.28); border:none;
  }
  .menu-panel{
    margin-bottom:10px; transition:all .28s ease; transform-origin:right bottom;
    background:rgba(255,255,255,0.96); color:#111; border-radius:10px; padding:12px;
    box-shadow:0 10px 30px rgba(0,0,0,0.28); width:320px;
    display:flex; flex-direction:column; gap:8px; align-items:stretch;
  }
  .menu-panel.hidden{ opacity:0; transform:scale(.96); pointer-events:none; height:0; margin:0; padding:0; width:54px }
  .menu-row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
  .menu-row .left{ display:flex; gap:8px; align-items:center; }
  .control-btn{
    padding:8px 10px; border-radius:8px; border:1px solid #ddd; background:#fff; color:#111; cursor:pointer; font-size:13px;
  }
  .control-btn.primary{ background:var(--accent); color:#fff; border:none; }
  .control-small{ padding:6px 8px; border-radius:6px; font-size:12px; background:#fff; color:#111; border:1px solid #ddd; cursor:pointer }
  .select-small{ padding:6px 8px; border-radius:6px; font-size:13px; }
  .menu-title{ font-weight:700; font-size:14px; color:#222; margin-bottom:2px }
  /* Result box: centered horizontal above footer (two lines) */
  .map-overlay{
    position:fixed; left:50%; transform:translateX(-50%); bottom:42px; z-index:4200;
    background:rgba(255,255,255,0.96); border-radius:10px; padding:10px 16px;
    min-width:260px; max-width:92%; box-shadow:0 6px 18px rgba(0,0,0,0.28);
    color:#111; text-align:center; display:flex; flex-direction:column; gap:6px; align-items:center;
    font-size:13px; line-height:1.2;
  }
  .map-overlay .row{ width:100%; display:flex; justify-content:center; gap:12px; align-items:center; flex-wrap:wrap }
  .map-overlay .txt { font-weight:700; color:#000; word-break:break-word; }
  .map-overlay .sub { font-weight:600; color:#333; font-size:12px; }
  /* Footer centered discreet */
  #footerApp{
    position:fixed; bottom:6px; left:0; right:0; text-align:center;
    font-size:11px; color:rgba(255,255,255,0.92); z-index:4200; text-shadow:0 0 6px rgba(0,0,0,0.5);
    pointer-events:none;
  }
  .muted{ color:#666; font-size:12px }
  @media (max-width:520px){
    .menu-panel{ width:92vw; right:8px }
    .map-overlay{ bottom:54px; padding:8px; min-width:200px; font-size:12px }
  }
</style>
</head>
<body>

<div id="map" role="application" aria-label="Mapa Safe Turn"></div>

<!-- App title top-left -->
<div id="appTitle">Safe Turn</div>

<!-- collapsible menu (right-bottom) -->
<div class="menu-wrapper" id="menuWrapper" aria-label="Menu">
  <div id="menuPanel" class="menu-panel hidden" role="region" aria-hidden="true">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="menu-title">Controles</div>
        <div class="muted" style="margin-top:2px">Toque para expandir/ocultar</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px">
        <button id="btnCloseMenu" class="control-small" title="Fechar">✕</button>
      </div>
    </div>

    <div class="menu-row">
      <div class="left">
        <button id="btnRecord" class="control-btn primary">Gravar</button>
        <button id="btnUndo" class="control-btn">Desfazer</button>
      </div>
      <div>
        <button id="btnClear" class="control-small">Limpar</button>
      </div>
    </div>

    <div class="menu-row">
      <div class="left">
        <label class="muted">Atrito</label>
        <select id="atrito" class="select-small">
          <option value="0.7">0.7</option>
          <option value="0.5">0.5</option>
          <option value="0.4">0.4</option>
          <option value="0.25">0.25</option>
        </select>
        <label class="muted">Veículo</label>
        <select id="veiculo" class="select-small">
          <option value="1">Padrão</option>
          <option value="0.75">Pesado</option>
        </select>
      </div>
    </div>

    <div class="menu-row">
      <div class="left">
        <button id="btnCalc" class="control-btn">Calcular</button>
        <button id="btnCenter" class="control-btn">Centralizar</button>
      </div>
      <div style="display:flex;gap:6px">
        <button id="btnCopy" class="control-small" title="Copiar dados">Copiar Dados</button>
        <button id="btnWA" class="control-small" title="Compartilhar via WhatsApp">WhatsApp</button>
      </div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
      <div class="muted">Exportar</div>
      <div style="display:flex;gap:8px">
        <button id="btnPNG" class="control-small">Gerar PNG</button>
      </div>
    </div>
  </div>

  <!-- handle (always visible) -->
  <button id="menuHandle" class="menu-handle" aria-expanded="false" aria-controls="menuPanel" title="Abrir menu">
    <span id="menuChevron" style="transform: rotate(0deg); display:inline-block;">❯</span>
  </button>
</div>

<!-- overlay centered above footer with two lines (linkable) -->
<div class="map-overlay" id="mapOverlay" aria-live="polite">
  <div class="row"><div class="sub">Localização</div></div>
  <div class="row"><div id="ovCenter" class="txt">-</div></div>
  <div class="row" style="margin-top:4px;"><div class="sub">Raio - Ângulo</div></div>
  <div class="row"><div id="ovRaioAng" class="txt">-</div></div>
</div>

<!-- footer -->
<div id="footerApp">Feito com ❤️ por Everton Tezzon Ferreira</div>

<!-- libs -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.7.0/leaflet.polylineDecorator.min.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>

<script>
/* ================== Helpers & Config ================== */
const TILE_PROVIDER = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
const G = 9.81;

function haversineKm(aLat,aLng,bLat,bLng){
  const R=6371; const dLat=(bLat-aLat)*Math.PI/180; const dLon=(bLng-aLng)*Math.PI/180;
  const A = Math.sin(dLat/2)**2 + Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*Math.sin(dLon/2)**2;
  const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
  return R*C;
}
function floorToNearest5(n){ return Math.max(0, Math.floor(n / 5) * 5); }

/* ================== Map init ================== */
const map = L.map('map', { zoomControl:true }).setView([-21.050964, -50.845963], 15);
const tileLayer = L.tileLayer(TILE_PROVIDER, { maxZoom:20, crossOrigin:true, errorTileUrl:'/offline-tile.png', attribution:'Esri' }).addTo(map);
tileLayer.on('tileerror', ()=> console.warn('tile error'));

// groups
const gpsGroup = L.layerGroup().addTo(map);        // only for live gps marker (not cleared)
const recordedGroup = L.layerGroup().addTo(map);   // for tracks, manual markers, curves

/* ================== State ================== */
let liveMarker = null;
let recording = false, watchId = null;
let track = [], trackLine = null, recordingDecorator = null;
let manualMarkers = [], points = [];
let curveLine = null, curveDecorator = null;

/* ================== Menu toggle ================== */
const menuPanel = document.getElementById('menuPanel');
const menuHandle = document.getElementById('menuHandle');
const menuChevron = document.getElementById('menuChevron');
const btnCloseMenu = document.getElementById('btnCloseMenu');
function openMenu(){ menuPanel.classList.remove('hidden'); menuPanel.setAttribute('aria-hidden','false'); menuHandle.setAttribute('aria-expanded','true'); menuChevron.style.transform='rotate(90deg)'; }
function closeMenu(){ menuPanel.classList.add('hidden'); menuPanel.setAttribute('aria-hidden','true'); menuHandle.setAttribute('aria-expanded','false'); menuChevron.style.transform='rotate(0deg)'; }
menuHandle.addEventListener('click', ()=> { if(menuPanel.classList.contains('hidden')) openMenu(); else closeMenu(); });
btnCloseMenu.addEventListener('click', ()=> closeMenu());
closeMenu();

/* ================== Geolocation ================== */
function onGeoErr(err){
  console.warn('geo err', err);
  const m = err && err.code===1 ? 'Permissão negada' : (err && err.code===2 ? 'Posição indisponível' : 'Erro de geolocalização');
  setOverlayLines(null, null, null, m);
}
function onPos(p){
  const lat = p.coords.latitude, lng = p.coords.longitude;

  if(!liveMarker){
    liveMarker = L.circleMarker([lat,lng], { radius:7, fillColor:'#e74c3c', color:'#c0392b', fillOpacity:0.95 }).addTo(gpsGroup);
  } else {
    liveMarker.setLatLng([lat,lng]);
  }

  if(!map._userCenteredOnce){ map._userCenteredOnce=true; map.setView([lat,lng],17); }

  if(recording){
    const last = track.length ? track[track.length-1] : null;
    const cand = {lat,lng,ts: Date.now()};
    if(!last) track.push(cand);
    else {
      const d = haversineKm(last.lat,last.lng,cand.lat,cand.lng) * 1000;
      const dt = cand.ts - last.ts;
      if(d >= 1.5 || dt >= 600) track.push(cand);
    }
    redrawRecordingLine();
  }

  setOverlayLines(null, null, null, 'GPS OK');
}
function startWatch(){
  if(!('geolocation' in navigator)){ setOverlayLines(null, null, null, 'Geolocalização não suportada'); return; }
  try{
    if(watchId) navigator.geolocation.clearWatch(watchId);
    watchId = navigator.geolocation.watchPosition(onPos, onGeoErr, { enableHighAccuracy:true, maximumAge:2000, timeout:20000 });
    navigator.geolocation.getCurrentPosition(onPos, onGeoErr, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
  } catch(e){
    console.error('watch fail', e);
    setOverlayLines(null, null, null, 'Erro ao ativar GPS');
  }
}
startWatch();

/* center button */
document.getElementById('btnCenter').addEventListener('click', ()=>{
  if(liveMarker && liveMarker.getLatLng) { map.setView(liveMarker.getLatLng(), 17); }
  else setOverlayLines(null, null, null, 'GPS ainda não disponível');
});

/* ================== Drawing & Recording ================== */
function redrawRecordingLine(){
  try{ if(trackLine) recordedGroup.removeLayer(trackLine); }catch(e){}
  try{ if(recordingDecorator) recordedGroup.removeLayer(recordingDecorator); }catch(e){}
  if(track.length > 0){
    trackLine = L.polyline(track.map(p=>[p.lat,p.lng]), { color:'red', weight:4, opacity:0.95 }).addTo(recordedGroup);
    try{
      recordingDecorator = L.polylineDecorator(trackLine, {
        patterns: [{offset:'100%', repeat:0, symbol: L.Symbol.arrowHead({pixelSize:14, polygon:true, pathOptions:{color:'red', fillColor:'red', fillOpacity:1}})}]
      }).addTo(recordedGroup);
    }catch(e){ /* decorator optional */ }
  }
}

/* manual points via click */
map.on('click', e=>{
  if(points && points.length >= 3) clearCurveOnly();
  const mk = L.circleMarker(e.latlng, { radius:6, color:'#c0392b', fillColor:'#e74c3c', fillOpacity:0.95 }).addTo(recordedGroup);
  manualMarkers.push(mk);
  points.push(L.latLng(e.latlng.lat, e.latlng.lng));
  if(points.length === 3) plotCurvePoints(points[0], points[1], points[2]);
  else setOverlayLines(null, null, null, `Pontos: ${points.length} (adicione ${3-points.length})`);
});

/* undo / clear */
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if(manualMarkers.length){ try{ recordedGroup.removeLayer(manualMarkers.pop()); }catch(e){} points.pop(); setOverlayLines(null, null, null, points.length ? `Pontos: ${points.length}` : 'Aguardando pontos'); }
  else setOverlayLines(null, null, null, 'Nada para desfazer');
});
document.getElementById('btnClear').addEventListener('click', ()=>{
  // clear everything except gpsGroup (which holds liveMarker)
  recordedGroup.clearLayers();
  manualMarkers = []; points = []; track = [];
  try{ if(trackLine) recordedGroup.removeLayer(trackLine);}catch(e){}
  trackLine = null;
  try{ if(curveLine) recordedGroup.removeLayer(curveLine);}catch(e){}
  curveLine = null;
  try{ if(curveDecorator) recordedGroup.removeLayer(curveDecorator);}catch(e){}
  curveDecorator = null;

  // keep liveMarker, recenter to it
  if(liveMarker && liveMarker.getLatLng) map.setView(liveMarker.getLatLng(), 17);

  setOverlayLines(null, null, null, 'Aguardando pontos ou gravação');
});

/* record toggle */
document.getElementById('btnRecord').addEventListener('click', ()=>{
  recording = !recording;
  const btn = document.getElementById('btnRecord');
  btn.textContent = recording ? 'Parar' : 'Gravar';
  if(recording){
    track = []; try{ if(trackLine) recordedGroup.removeLayer(trackLine);}catch(e){} trackLine=null;
    if(liveMarker && liveMarker.getLatLng) track.push({lat: liveMarker.getLatLng().lat, lng: liveMarker.getLatLng().lng, ts: Date.now()});
    setOverlayLines(null, null, null, 'Gravando (aguardando movimento)');
  } else {
    if(track.length < 3){ alert('Track curto: registre um percurso maior ou adicione 3 pontos manualmente.'); redrawRecordingLine(); return; }
    const sel = selectThreeFromTrack(track);
    if(sel){ plotCurvePoints(sel.start, sel.mid, sel.end); try{ const bounds = L.latLngBounds(track.map(p=>[p.lat,p.lng])); map.fitBounds(bounds.pad(0.2)); }catch(e){} }
    else alert('Não foi possível selecionar 3 pontos automaticamente.');
  }
});

/* ================== Geometry & Plot ================== */
function perpDistanceToLine(a,b,p){
  const latAvg = ((a.lat + b.lat + p.lat)/3) * Math.PI/180;
  const R = 6371000;
  const ax = a.lng * Math.PI/180 * R * Math.cos(latAvg), ay = a.lat * Math.PI/180 * R;
  const bx = b.lng * Math.PI/180 * R * Math.cos(latAvg), by = b.lat * Math.PI/180 * R;
  const px = p.lng * Math.PI/180 * R * Math.cos(latAvg), py = p.lat * Math.PI/180 * R;
  const vx = bx-ax, vy = by-ay, wx = px-ax, wy = py-ay;
  const vlen2 = vx*vx + vy*vy;
  if(vlen2===0) return Math.sqrt(wx*wx + wy*wy);
  const t = (wx*vx + wy*vy) / vlen2;
  const projx = ax + t*vx, projy = ay + t*vy;
  const dx = px - projx, dy = py - projy;
  return Math.sqrt(dx*dx + dy*dy);
}
function selectThreeFromTrack(trk){
  if(!trk || trk.length < 3) return null;
  const start = {lat: trk[0].lat, lng: trk[0].lng};
  const end = {lat: trk[trk.length-1].lat, lng: trk[trk.length-1].lng};
  let maxDist=-1, midIdx=0;
  for(let i=0;i<trk.length;i++){
    const d = perpDistanceToLine(start,end,trk[i]);
    if(d>maxDist){ maxDist=d; midIdx=i; }
  }
  return { start, mid: trk[midIdx], end, midIndex: midIdx, maxDist };
}

function clearCurveOnly(){
  try{ if(curveLine) recordedGroup.removeLayer(curveLine);}catch(e){}
  try{ if(curveDecorator) recordedGroup.removeLayer(curveDecorator);}catch(e){}
  manualMarkers.forEach(m=>{ try{ recordedGroup.removeLayer(m);}catch(e){} });
  manualMarkers = []; curveLine = null; curveDecorator = null; points = [];
  setOverlayLines(null, null, null, 'Aguardando pontos ou gravação');
}

function plotCurvePoints(p1,p2,p3){
  clearCurveOnly();
  const P1=L.latLng(p1.lat||p1[0], p1.lng||p1[1]);
  const P2=L.latLng(p2.lat||p2[0], p2.lng||p2[1]);
  const P3=L.latLng(p3.lat||p3[0], p3.lng||p3[1]);

  L.circleMarker([P1.lat,P1.lng], { radius:6, color:'#27ae60', fillColor:'#2ecc71', fillOpacity:0.95 }).addTo(recordedGroup);
  L.circleMarker([P2.lat,P2.lng], { radius:6, color:'#f39c12', fillColor:'#f1c40f', fillOpacity:0.95 }).addTo(recordedGroup);
  L.circleMarker([P3.lat,P3.lng], { radius:6, color:'#2980b9', fillColor:'#3498db', fillOpacity:0.95 }).addTo(recordedGroup);

  curveLine = L.polyline([[P1.lat,P1.lng],[P2.lat,P2.lng],[P3.lat,P3.lng]], { color:'#8e44ad', weight:3, dashArray:'8 6' }).addTo(recordedGroup);
  try{ curveDecorator = L.polylineDecorator(curveLine, {
    patterns: [{offset:'100%', repeat:0, symbol: L.Symbol.arrowHead({pixelSize:18, polygon:true, pathOptions:{color:'#8e44ad', fillColor:'#8e44ad', fillOpacity:1}})}]
  }).addTo(recordedGroup);}catch(e){ console.warn('decorator fail', e); }

  points = [P1,P2,P3];
  const geom = calcularGeometria();
  if(geom) {
    setOverlayLines(geom.center, geom.R, geom.deltaDeg, 'Curva calculada');
  }
}

/* core calculation returns center */
function calcularGeometria(){
  if(!points || points.length < 3){ setOverlayLines(null, null, null, 'Aguardando 3 pontos'); return null; }
  const p1 = points[0], p2 = points[1], p3 = points[2];
  const c = haversineKm(p1.lat,p1.lng,p3.lat,p3.lng) * 1000;
  const midLat = (p1.lat + p3.lat)/2, midLng = (p1.lng + p3.lng)/2;
  const s = haversineKm(p2.lat,p2.lng, midLat, midLng) * 1000;
  if(s === 0){ setOverlayLines(null, null, null, 'Sagita zero — escolha outros pontos'); return null; }
  const R = (c*c)/(8*s) + s/2;
  const theta = 2 * Math.asin(Math.min(1, c/(2*R)));
  const deltaDeg = theta * 180/Math.PI;
  const arcLen = R * theta;

  const mu = parseFloat(document.getElementById('atrito').value || 0.7);
  const vehicleFactor = parseFloat(document.getElementById('veiculo').value || 1.0);
  const marginFactor = 0.78;
  const vmax = Math.sqrt(mu * G * R);
  const vrecom_m_s = vmax * vehicleFactor * marginFactor;
  const vrecom_kmh_raw = vrecom_m_s * 3.6;
  const vrecom_kmh = floorToNearest5(vrecom_kmh_raw);
  const vs_kmh = Math.max(0, vrecom_kmh - 5);

  const center = (function(a,b,c){
    const latRef = (a.lat + b.lat + c.lat)/3;
    function toXY(pt){ const Rm=6371000; return { x: pt.lng*Math.PI/180*Rm*Math.cos(latRef*Math.PI/180), y: pt.lat*Math.PI/180*Rm }; }
    const A=toXY(a), B=toXY(b), C=toXY(c);
    const x1=A.x,y1=A.y,x2=B.x,y2=B.y,x3=C.x,y3=C.y;
    const D = 2*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    if(Math.abs(D) < 1e-6) return { lat:(a.lat + c.lat)/2, lng:(a.lng + c.lng)/2 };
    const x1sq=x1*x1+y1*y1, x2sq=x2*x2+y2*y2, x3sq=x3*x3+y3*y3;
    const ux = (x1sq*(y2-y3)+x2sq*(y3-y1)+x3sq*(y1-y2))/D;
    const uy = (x1sq*(x3-x2)+x2sq*(x1-x3)+x3sq*(x2-x1))/D;
    const Rm = 6371000;
    return { lat: (uy/Rm)*180/Math.PI, lng: (ux/(Rm*Math.cos(latRef*Math.PI/180)))*180/Math.PI };
  })(p1,p2,p3);

  const res = { R, deltaDeg, arcLen, s, c, vrecom_kmh_raw, vrecom_kmh, vs_kmh, center };
  setOverlayLines(res.center, res.R, res.deltaDeg, 'Curva calculada');
  return res;
}

/* overlay: two-line box with clickable google link */
function setOverlayLines(center, R, delta, message){
  const ovCenter = document.getElementById('ovCenter');
  if(center){
    const gLink = `https://www.google.com/maps?q=${center.lat.toFixed(6)},${center.lng.toFixed(6)}`;
    ovCenter.innerHTML = `<a href="${gLink}" target="_blank" rel="noopener" style="color:#1a73e8;text-decoration:underline">${center.lat.toFixed(6)} - ${center.lng.toFixed(6)}</a>`;
  } else {
    ovCenter.textContent = '-';
  }
  document.getElementById('ovRaioAng').textContent = (R ? `${R.toFixed(2)} m` : '-') + '  -  ' + (delta ? `${delta.toFixed(2)}°` : '-');
  if(message) console.log('SafeTurn:', message);
}

/* ========== Buttons: Calc / Copy / WhatsApp / PNG ========== */
document.getElementById('btnCalc').addEventListener('click', ()=> {
  const r = calcularGeometria();
  if(!r) alert('Defina 3 pontos (manual) ou grave movimento e pare para cálculo.');
});

/* Copy data (clipboard) with Google Maps link */
document.getElementById('btnCopy').addEventListener('click', async ()=>{
  const geom = calcularGeometria();
  if(!geom){ alert('Defina curva antes de copiar.'); return; }
  const center = geom.center;
  const gLink = `https://www.google.com/maps?q=${center.lat.toFixed(6)},${center.lng.toFixed(6)}`;
  const text =
`Localização:
${gLink}
VR: ${geom.vrecom_kmh} km/h
VS: ${geom.vs_kmh} km/h`;
  try{
    await navigator.clipboard.writeText(text);
    showTemporaryStatus('Copiado para a área de transferência', 1600);
  }catch(e){
    // fallback
    const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta);
    ta.select(); try{ document.execCommand('copy'); showTemporaryStatus('Copiado (fallback)', 1600); }catch(ex){ alert('Erro ao copiar'); }
    ta.remove();
  }
});

/* WhatsApp sharing: message with "Localização:" and google link */
document.getElementById('btnWA').addEventListener('click', ()=>{
  const geom = calcularGeometria();
  if(!geom){ alert('Defina curva antes de compartilhar.'); return; }
  const center = geom.center;
  const gLink = `https://www.google.com/maps?q=${center.lat.toFixed(6)},${center.lng.toFixed(6)}`;
  const message =
`Localização:
${gLink}
VR: ${geom.vrecom_kmh} km/h
VS: ${geom.vs_kmh} km/h`;
  showTemporaryStatus('Compartilhando os dados agora...', 1500);
  window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, '_blank');
});

/* small toast/status */
function showTemporaryStatus(txt, ms=1200){
  const s = document.createElement('div');
  s.textContent = txt;
  s.style.position='fixed'; s.style.right='16px'; s.style.bottom='86px'; s.style.zIndex=9999;
  s.style.background='rgba(0,0,0,0.75)'; s.style.color='#fff'; s.style.padding='8px 12px';
  s.style.borderRadius='8px'; s.style.fontSize='13px'; s.style.boxShadow='0 8px 20px rgba(0,0,0,0.4)';
  document.body.appendChild(s);
  setTimeout(()=> { s.style.transition='opacity .3s'; s.style.opacity='0'; setTimeout(()=> s.remove(), 350); }, ms);
}

/* ================== PNG export: ensure arrow clone is captured ========== */
function createArrowClone(){
  if(!curveLine) return null;
  const latlngs = curveLine.getLatLngs();
  if(!latlngs || latlngs.length < 2) return null;
  const a = latlngs[latlngs.length-2];
  const b = latlngs[latlngs.length-1];
  return L.polyline([a,b], {color:'#8e44ad', weight:6, opacity:1});
}

document.getElementById('btnPNG').addEventListener('click', async ()=>{
  const geom = calcularGeometria();
  if(!geom){ alert('Defina curva antes de gerar PNG.'); return; }

  if(typeof leafletImage !== 'function'){
    alert('leaflet-image não disponível — verifique conexão.');
    return;
  }

  // create arrow clone (if curve exists)
  const arrowClone = createArrowClone();
  if(arrowClone) arrowClone.addTo(recordedGroup);

  try{
    await new Promise((resolve, reject) => {
      leafletImage(map, function(err, mapCanvas){
        if(err || !mapCanvas) return reject(err || new Error('leaflet-image falhou'));
        try{
          // final canvas
          const final = document.createElement('canvas');
          final.width = mapCanvas.width; final.height = mapCanvas.height;
          const ctx = final.getContext('2d');
          ctx.drawImage(mapCanvas, 0, 0);

          // draw app name top-left
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(10, 10, 120, 36);
          ctx.fillStyle = '#fff';
          ctx.font = Math.max(14, Math.round(final.width*0.02)) + 'px sans-serif';
          ctx.fillText('Safe Turn', 18, 34);

          // centered box above footer with two lines
          const boxW = Math.min(final.width - 40, Math.max(260, Math.round(final.width * 0.6)));
          const boxH = Math.round(final.height * 0.12);
          const boxX = (final.width - boxW) / 2;
          const boxY = final.height - boxH - 36;

          ctx.fillStyle = 'rgba(255,255,255,0.96)';
          roundRect(ctx, boxX, boxY, boxW, boxH, 12, true, false);

          ctx.fillStyle = '#111'; ctx.textAlign = 'center';
          ctx.font = Math.max(12, Math.round(final.width*0.016)) + 'px sans-serif';
          ctx.fillText(`${geom.center.lat.toFixed(6)} - ${geom.center.lng.toFixed(6)}`, final.width/2, boxY + Math.round(boxH*0.45));
          ctx.fillText(`${geom.R.toFixed(2)} m  -  ${geom.deltaDeg.toFixed(2)}°`, final.width/2, boxY + Math.round(boxH*0.80));
          ctx.textAlign = 'left';

          // footer
          ctx.fillStyle = 'rgba(255,255,255,0.92)';
          ctx.font = Math.max(10, Math.round(final.width*0.012)) + 'px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Feito com ❤️ por Everton Tezzon Ferreira', final.width / 2, final.height - 12);
          ctx.textAlign = 'left';

          final.toBlob(function(blob){
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'SafeTurn_map.png';
            document.body.appendChild(a); a.click(); a.remove();
            setTimeout(()=> URL.revokeObjectURL(url), 1500);
          }, 'image/png');

          resolve();
        } catch(drawErr){
          reject(drawErr);
        } finally {
          // remove arrow clone from map after capture
          if(arrowClone) try{ recordedGroup.removeLayer(arrowClone); }catch(e){}
        }
      });
    });
  } catch(e){
    console.warn('capture failed, fallback drawing', e);
    showTemporaryStatus('Erro ao gerar PNG', 2000);
    if(arrowClone) try{ recordedGroup.removeLayer(arrowClone); }catch(e){}
  }
});

/* helper to draw rounded rectangle */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* init overlay defaults */
setOverlayLines(null, null, null, 'Aguardando 3 pontos ou gravação');

/* expose for debug */
window.SafeTurn = { calcularGeometria };

</script>
</body>
</html>