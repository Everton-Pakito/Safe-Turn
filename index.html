<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Safe Turn</title>
<link rel="manifest" href="./manifest.json"/>
<meta name="theme-color" content="#141414"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  :root{ --accent:#3498db; --muted:#666; }
  html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial;background:#000;color:#fff}
  /* Fullscreen map */
  #map{position:fixed;inset:0;width:100%;height:100vh;z-index:0}
  /* App title top-left */
  #appTitle{
    position:fixed; top:10px; left:12px; z-index:4300;
    background:rgba(0,0,0,0.55); padding:6px 10px; border-radius:6px;
    font-size:16px; color:#fff; font-weight:700; backdrop-filter: blur(4px);
    pointer-events:none;
  }
  /* Floating controls (below title) */
  .floating-controls{
    position:fixed; left:12px; top:52px; z-index:4500;
    background:rgba(255,255,255,0.92); border-radius:10px; padding:8px;
    box-shadow:0 6px 18px rgba(0,0,0,.18); display:flex; gap:6px; flex-wrap:wrap; align-items:center;
  }
  .floating-controls button, .floating-controls select{
    font-size:13px; padding:8px; border-radius:7px; border:1px solid #ddd;
    cursor:pointer; background:#fff; color:#111;
  }
  .floating-controls button.primary{ background:var(--accent); color:#fff; border:none }
  /* GPS hint popup (top-center) */
  .gps-hint{
    position:fixed; top:12px; left:50%; transform:translateX(-50%); z-index:4600;
    background:rgba(255,255,255,0.96); padding:10px 14px; border-radius:8px;
    box-shadow:0 6px 20px rgba(0,0,0,0.25); font-size:14px; color:#111;
    display:flex; gap:10px; align-items:center;
  }
  .gps-hint button{ background:var(--accent); color:#fff; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; }
  /* Result box: centered horizontal above footer (two lines) */
  .map-overlay{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:42px; /* above footer */
    z-index:4200;
    background:rgba(255,255,255,0.96);
    border-radius:10px;
    padding:10px 16px;
    min-width:260px;
    max-width:92%;
    box-shadow:0 6px 18px rgba(0,0,0,0.28);
    color:#111;
    text-align:center;
    display:flex;
    flex-direction:column;
    gap:6px;
    align-items:center;
    font-size:13px;
    line-height:1.2;
  }
  .map-overlay .row{ width:100%; display:flex; justify-content:center; gap:12px; align-items:center; flex-wrap:wrap }
  .map-overlay .txt { font-weight:700; color:#000; }
  .map-overlay .sub { font-weight:600; color:#333; font-size:12px; }
  /* Footer centered discreet */
  #footerApp{
    position:fixed; bottom:6px; left:0; right:0; text-align:center;
    font-size:11px; color:rgba(255,255,255,0.92); z-index:4200; text-shadow:0 0 6px rgba(0,0,0,0.5);
    pointer-events:none;
  }
  @media (max-width:700px){
    #appTitle{ top:8px; left:8px; font-size:14px }
    .floating-controls{ left:8px; top:46px; padding:6px }
    .map-overlay{ bottom:54px; padding:8px; min-width:200px; font-size:12px }
    .gps-hint{ font-size:13px; padding:8px }
  }
  @media print { .floating-controls, .gps-hint { display:none } }
</style>
</head>
<body>

<div id="map" role="application" aria-label="Mapa Safe Turn"></div>

<!-- App title top-left -->
<div id="appTitle">Safe Turn</div>

<!-- floating controls -->
<div class="floating-controls" id="controls" role="region" aria-label="Controles">
  <button id="btnRecord" class="primary">Gravar Movimento</button>
  <button id="btnUndo">Desfazer</button>
  <button id="btnClear">Limpar</button>
  <button id="btnCenter">Centralizar GPS</button>

  <label style="display:flex;align-items:center;gap:6px">
    Atrito
    <select id="atrito" title="coeficiente de atrito">
      <option value="0.7">0.7</option>
      <option value="0.5">0.5</option>
      <option value="0.4">0.4</option>
      <option value="0.25">0.25</option>
    </select>
  </label>

  <label style="display:flex;align-items:center;gap:6px">
    Veículo
    <select id="veiculo" title="fator veículo">
      <option value="1">Padrão</option>
      <option value="0.75">Pesado</option>
    </select>
  </label>

  <button id="btnCalc">Calcular</button>
  <button id="btnPNG">Gerar PNG</button>
  <button id="btnWA">WhatsApp</button>
</div>

<!-- gps hint popup (shows until closed) -->
<div id="gpsHint" class="gps-hint" style="display:none" role="dialog" aria-live="polite">
  <div style="max-width:640px">Dica: ative <strong>Alta precisão</strong> no GPS do seu dispositivo para melhor fix. Clique 3 pontos manualmente ou grave um movimento para mapear a curva.</div>
  <div style="margin-left:6px"><button id="gpsHintClose">OK</button></div>
</div>

<!-- overlay centered above footer with two lines -->
<div class="map-overlay" id="mapOverlay" aria-live="polite">
  <div class="row"><div class="sub">Lat - Long:</div></div>
  <div class="row"><div id="ovCenter" class="txt">-</div></div>
  <div class="row" style="margin-top:2px;"><div class="sub">Raio - Ângulo:</div></div>
  <div class="row"><div id="ovRaioAng" class="txt">-</div></div>
</div>

<!-- footer -->
<div id="footerApp">Feito com ❤️ por Everton Tezzon Ferreira</div>

<!-- libs -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.7.0/leaflet.polylineDecorator.min.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>

<script>
/* ================== Helpers & Config ================== */
const TILE_PROVIDER = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
const G = 9.81;
function haversineKm(aLat,aLng,bLat,bLng){
  const R=6371; const dLat=(bLat-aLat)*Math.PI/180; const dLon=(bLng-aLng)*Math.PI/180;
  const A = Math.sin(dLat/2)**2 + Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*Math.sin(dLon/2)**2;
  const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
  return R*C;
}
function floorToNearest5(n){ return Math.max(0, Math.floor(n / 5) * 5); }

/* New overlay: two lines only */
function setOverlayLines(center, R, delta, message){
  document.getElementById('ovCenter').textContent = center ? `${center.lat.toFixed(6)} - ${center.lng.toFixed(6)}` : '-';
  document.getElementById('ovRaioAng').textContent = (R ? `${R.toFixed(2)} m` : '-') + '  -  ' + (delta ? `${delta.toFixed(2)}°` : '-');
  if(message) {
    // temporarily show message in the overlay subtitle (brief)
    // We won't block layout; instead we console.log
    console.log('SafeTurn:', message);
  }
}

/* ================== Map init ================== */
const map = L.map('map', { zoomControl:true }).setView([-21.050964, -50.845963], 15);
const tileLayer = L.tileLayer(TILE_PROVIDER, { maxZoom:20, crossOrigin:true, errorTileUrl:'/offline-tile.png', attribution:'Esri' }).addTo(map);
tileLayer.on('tileerror', ()=> console.warn('tile error'));
const recordedGroup = L.layerGroup().addTo(map);

/* ================== State ================== */
let liveMarker = null;
let recording = false, watchId = null;
let track = [], trackLine = null, recordingDecorator = null;
let manualMarkers = [], points = [];
let curveLine = null, curveDecorator = null;

/* ================== GPS Hint logic ================== */
const gpsHintEl = document.getElementById('gpsHint');
const gpsHintCloseBtn = document.getElementById('gpsHintClose');
if(!localStorage.getItem('safeTurn_gpsHintDismissed')){
  gpsHintEl.style.display = 'flex';
}
gpsHintCloseBtn.addEventListener('click', ()=>{
  gpsHintEl.style.display = 'none';
  localStorage.setItem('safeTurn_gpsHintDismissed', '1');
});

/* ================== Geolocation ================== */
function onGeoErr(err){
  console.warn('geo err', err);
  const m = err && err.code===1 ? 'Permissão negada' : (err && err.code===2 ? 'Posição indisponível' : 'Erro de geolocalização');
  setOverlayLines(null, null, null, m);
}
function onPos(p){
  const lat = p.coords.latitude, lng = p.coords.longitude;
  if(!liveMarker) liveMarker = L.circleMarker([lat,lng], { radius:7, fillColor:'#e74c3c', color:'#c0392b', fillOpacity:0.95 }).addTo(recordedGroup);
  else liveMarker.setLatLng([lat,lng]);
  if(!map._userCenteredOnce){ map._userCenteredOnce=true; map.setView([lat,lng],17); }
  if(recording){
    const last = track.length ? track[track.length-1] : null;
    const cand = {lat,lng,ts: Date.now()};
    if(!last) track.push(cand);
    else {
      const d = haversineKm(last.lat,last.lng,cand.lat,cand.lng) * 1000;
      const dt = cand.ts - last.ts;
      if(d >= 1.5 || dt >= 600) track.push(cand);
    }
    redrawRecordingLine();
  }
  setOverlayLines(null, null, null, 'GPS OK');
}
function startWatch(){
  if(!('geolocation' in navigator)){ setOverlayLines(null, null, null, 'Geolocalização não suportada'); return; }
  try{
    if(watchId) navigator.geolocation.clearWatch(watchId);
    watchId = navigator.geolocation.watchPosition(onPos, onGeoErr, { enableHighAccuracy:true, maximumAge:2000, timeout:20000 });
    navigator.geolocation.getCurrentPosition(onPos, onGeoErr, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
  } catch(e){
    console.error('watch fail', e);
    setOverlayLines(null, null, null, 'Erro ao ativar GPS');
  }
}
startWatch();

/* center button */
document.getElementById('btnCenter').addEventListener('click', ()=>{
  if(liveMarker && liveMarker.getLatLng) { map.setView(liveMarker.getLatLng(), 17); }
  else setOverlayLines(null, null, null, 'GPS ainda não disponível');
});

/* ================== Drawing & Recording ================== */
function redrawRecordingLine(){
  try{ if(trackLine) recordedGroup.removeLayer(trackLine); }catch(e){}
  try{ if(recordingDecorator) recordedGroup.removeLayer(recordingDecorator); }catch(e){}
  if(track.length > 0){
    trackLine = L.polyline(track.map(p=>[p.lat,p.lng]), { color:'red', weight:4, opacity:0.95 }).addTo(recordedGroup);
    recordingDecorator = L.polylineDecorator(trackLine, {
      patterns: [{offset:'100%', repeat:0, symbol: L.Symbol.arrowHead({pixelSize:14, polygon:true, pathOptions:{color:'red', fillColor:'red', fillOpacity:1}})}]
    }).addTo(recordedGroup);
  }
}

/* manual points via click */
map.on('click', e=>{
  if(points && points.length >= 3) clearCurveOnly();
  const mk = L.circleMarker(e.latlng, { radius:6, color:'#c0392b', fillColor:'#e74c3c', fillOpacity:0.95 }).addTo(map);
  manualMarkers.push(mk);
  points.push(L.latLng(e.latlng.lat, e.latlng.lng));
  if(points.length === 3) plotCurvePoints(points[0], points[1], points[2]);
  else setOverlayLines(null, null, null, `Pontos: ${points.length} (adicione ${3-points.length})`);
});

/* undo / clear */
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if(manualMarkers.length){ try{ map.removeLayer(manualMarkers.pop()); }catch(e){} points.pop(); setOverlayLines(null, null, null, points.length ? `Pontos: ${points.length}` : 'Aguardando pontos'); }
  else setOverlayLines(null, null, null, 'Nada para desfazer');
});
document.getElementById('btnClear').addEventListener('click', ()=>{
  try{ recordedGroup.clearLayers(); }catch(e){}
  manualMarkers = []; points = []; track = []; try{ if(trackLine) recordedGroup.removeLayer(trackLine);}catch(e){} trackLine=null;
  setOverlayLines(null, null, null, 'Aguardando pontos ou gravação');
});

/* record toggle */
document.getElementById('btnRecord').addEventListener('click', ()=>{
  recording = !recording;
  document.getElementById('btnRecord').textContent = recording ? 'Parar Gravação' : 'Gravar Movimento';
  if(recording){
    track = []; try{ if(trackLine) recordedGroup.removeLayer(trackLine);}catch(e){} trackLine=null;
    if(liveMarker && liveMarker.getLatLng) track.push({lat: liveMarker.getLatLng().lat, lng: liveMarker.getLatLng().lng, ts: Date.now()});
    setOverlayLines(null, null, null, 'Gravando (aguardando movimento)');
  } else {
    if(track.length < 3){ alert('Track curto: registre um percurso maior ou adicione 3 pontos manualmente.'); redrawRecordingLine(); return; }
    const sel = selectThreeFromTrack(track);
    if(sel){ plotCurvePoints(sel.start, sel.mid, sel.end); try{ const bounds = L.latLngBounds(track.map(p=>[p.lat,p.lng])); map.fitBounds(bounds.pad(0.2)); }catch(e){} }
    else alert('Não foi possível selecionar 3 pontos automaticamente.');
  }
});

/* ================== Geometry & Plot ================== */
function perpDistanceToLine(a,b,p){
  const latAvg = ((a.lat + b.lat + p.lat)/3) * Math.PI/180;
  const R = 6371000;
  const ax = a.lng * Math.PI/180 * R * Math.cos(latAvg), ay = a.lat * Math.PI/180 * R;
  const bx = b.lng * Math.PI/180 * R * Math.cos(latAvg), by = b.lat * Math.PI/180 * R;
  const px = p.lng * Math.PI/180 * R * Math.cos(latAvg), py = p.lat * Math.PI/180 * R;
  const vx = bx-ax, vy = by-ay, wx = px-ax, wy = py-ay;
  const vlen2 = vx*vx + vy*vy;
  if(vlen2===0) return Math.sqrt(wx*wx + wy*wy);
  const t = (wx*vx + wy*vy) / vlen2;
  const projx = ax + t*vx, projy = ay + t*vy;
  const dx = px - projx, dy = py - projy;
  return Math.sqrt(dx*dx + dy*dy);
}
function selectThreeFromTrack(trk){
  if(!trk || trk.length < 3) return null;
  const start = {lat: trk[0].lat, lng: trk[0].lng};
  const end = {lat: trk[trk.length-1].lat, lng: trk[trk.length-1].lng};
  let maxDist=-1, midIdx=0;
  for(let i=0;i<trk.length;i++){
    const d = perpDistanceToLine(start,end,trk[i]);
    if(d>maxDist){ maxDist=d; midIdx=i; }
  }
  return { start, mid: trk[midIdx], end, midIndex: midIdx, maxDist };
}

function clearCurveOnly(){
  try{ if(curveLine) recordedGroup.removeLayer(curveLine);}catch(e){}
  try{ if(curveDecorator) recordedGroup.removeLayer(curveDecorator);}catch(e){}
  manualMarkers.forEach(m=>{ try{ map.removeLayer(m);}catch(e){} });
  manualMarkers = []; curveLine = null; curveDecorator = null; points = [];
  setOverlayLines(null, null, null, 'Aguardando pontos ou gravação');
}

function plotCurvePoints(p1,p2,p3){
  clearCurveOnly();
  const P1=L.latLng(p1.lat||p1[0], p1.lng||p1[1]);
  const P2=L.latLng(p2.lat||p2[0], p2.lng||p2[1]);
  const P3=L.latLng(p3.lat||p3[0], p3.lng||p3[1]);

  L.circleMarker([P1.lat,P1.lng], { radius:6, color:'#27ae60', fillColor:'#2ecc71', fillOpacity:0.95 }).addTo(recordedGroup);
  L.circleMarker([P2.lat,P2.lng], { radius:6, color:'#f39c12', fillColor:'#f1c40f', fillOpacity:0.95 }).addTo(recordedGroup);
  L.circleMarker([P3.lat,P3.lng], { radius:6, color:'#2980b9', fillColor:'#3498db', fillOpacity:0.95 }).addTo(recordedGroup);

  curveLine = L.polyline([[P1.lat,P1.lng],[P2.lat,P2.lng],[P3.lat,P3.lng]], { color:'#8e44ad', weight:3, dashArray:'8 6' }).addTo(recordedGroup);
  try{ curveDecorator = L.polylineDecorator(curveLine, {
    patterns: [{offset:'100%', repeat:0, symbol: L.Symbol.arrowHead({pixelSize:18, polygon:true, pathOptions:{color:'#8e44ad', fillColor:'#8e44ad', fillOpacity:1}})}]
  }).addTo(recordedGroup);}catch(e){ console.warn('decorator fail', e); }

  points = [P1,P2,P3];
  const geom = calcularGeometria();
  if(geom) {
    setOverlayLines(geom.center, geom.R, geom.deltaDeg, 'Curva calculada');
  }
}

/* core calculation returns center */
function calcularGeometria(){
  if(!points || points.length < 3){ setOverlayLines(null, null, null, 'Aguardando 3 pontos'); return null; }
  const p1 = points[0], p2 = points[1], p3 = points[2];
  const c = haversineKm(p1.lat,p1.lng,p3.lat,p3.lng) * 1000;
  const midLat = (p1.lat + p3.lat)/2, midLng = (p1.lng + p3.lng)/2;
  const s = haversineKm(p2.lat,p2.lng, midLat, midLng) * 1000;
  if(s === 0){ setOverlayLines(null, null, null, 'Sagita zero — escolha outros pontos'); return null; }
  const R = (c*c)/(8*s) + s/2;
  const theta = 2 * Math.asin(Math.min(1, c/(2*R)));
  const deltaDeg = theta * 180/Math.PI;
  const arcLen = R * theta;

  const mu = parseFloat(document.getElementById('atrito').value || 0.7);
  const vehicleFactor = parseFloat(document.getElementById('veiculo').value || 1.0);
  const marginFactor = 0.78;
  const vmax = Math.sqrt(mu * G * R);
  const vrecom_m_s = vmax * vehicleFactor * marginFactor;
  const vrecom_kmh_raw = vrecom_m_s * 3.6;
  const vrecom_kmh = floorToNearest5(vrecom_kmh_raw);
  const vs_kmh = Math.max(0, vrecom_kmh - 5);

  const center = (function(a,b,c){
    const latRef = (a.lat + b.lat + c.lat)/3;
    function toXY(pt){ const Rm=6371000; return { x: pt.lng*Math.PI/180*Rm*Math.cos(latRef*Math.PI/180), y: pt.lat*Math.PI/180*Rm }; }
    const A=toXY(a), B=toXY(b), C=toXY(c);
    const x1=A.x,y1=A.y,x2=B.x,y2=B.y,x3=C.x,y3=C.y;
    const D = 2*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    if(Math.abs(D) < 1e-6) return { lat:(a.lat + c.lat)/2, lng:(a.lng + c.lng)/2 };
    const x1sq=x1*x1+y1*y1, x2sq=x2*x2+y2*y2, x3sq=x3*x3+y3*y3;
    const ux = (x1sq*(y2-y3)+x2sq*(y3-y1)+x3sq*(y1-y2))/D;
    const uy = (x1sq*(x3-x2)+x2sq*(x1-x3)+x3sq*(x2-x1))/D;
    const Rm = 6371000;
    return { lat: (uy/Rm)*180/Math.PI, lng: (ux/(Rm*Math.cos(latRef*Math.PI/180)))*180/Math.PI };
  })(p1,p2,p3);

  const res = { R, deltaDeg, arcLen, s, c, vrecom_kmh_raw, vrecom_kmh, vs_kmh, center };
  setOverlayLines(res.center, res.R, res.deltaDeg, 'Curva calculada');
  return res;
}

/* Calculate button */
document.getElementById('btnCalc').addEventListener('click', ()=> {
  const r = calcularGeometria();
  if(!r) alert('Defina 3 pontos (manual) ou grave movimento e pare para cálculo.');
});

/* WhatsApp sharing */
document.getElementById('btnWA').addEventListener('click', ()=>{
  const geom = calcularGeometria();
  if(!geom){ alert('Defina curva antes de compartilhar.'); return; }
  const center = geom.center;
  const mapsLink = `https://www.google.com/maps/search/?api=1&query=${center.lat.toFixed(6)},${center.lng.toFixed(6)}`;
  const message = `Link:\n${mapsLink}\nVR: ${geom.vrecom_kmh} km/h\nVS: ${geom.vs_kmh} km/h`;
  window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, '_blank');
});

/* ========== PNG export: capture map canvas + app name + centered bottom box ========== */
document.getElementById('btnPNG').addEventListener('click', async ()=>{
  const geom = calcularGeometria();
  if(!geom){ alert('Defina curva antes de gerar PNG.'); return; }

  if(typeof leafletImage !== 'function'){
    alert('leaflet-image não disponível — verifique conexão.');
    return;
  }

  try{
    await new Promise((resolve, reject) => {
      leafletImage(map, function(err, mapCanvas){
        if(err || !mapCanvas) return reject(err || new Error('leaflet-image falhou'));
        try{
          // final canvas
          const final = document.createElement('canvas');
          final.width = mapCanvas.width;
          final.height = mapCanvas.height;
          const ctx = final.getContext('2d');

          // draw map
          ctx.drawImage(mapCanvas, 0, 0);

          // draw app name top-left (so it appears on the PNG)
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(10, 10, 110, 34);
          ctx.fillStyle = '#fff';
          ctx.font = Math.max(14, Math.round(final.width*0.02)) + 'px sans-serif';
          ctx.fillText('Safe Turn', 18, 34);

          // centered box above footer (two lines)
          const boxW = Math.min(final.width - 40, Math.max(260, Math.round(final.width * 0.6)));
          const boxH = Math.round(final.height * 0.12);
          const boxX = (final.width - boxW) / 2;
          const boxY = final.height - boxH - 36; // leave space for footer

          ctx.fillStyle = 'rgba(255,255,255,0.96)';
          roundRect(ctx, boxX, boxY, boxW, boxH, 12, true, false);

          // text inside box (centered)
          ctx.fillStyle = '#111';
          ctx.textAlign = 'center';
          ctx.font = Math.max(12, Math.round(final.width*0.016)) + 'px sans-serif';
          ctx.fillText(`${geom.center.lat.toFixed(6)} - ${geom.center.lng.toFixed(6)}`, final.width/2, boxY + Math.round(boxH*0.43));
          ctx.fillText(`${geom.R.toFixed(2)} m  -  ${geom.deltaDeg.toFixed(2)}°`, final.width/2, boxY + Math.round(boxH*0.78));
          ctx.textAlign = 'left';

          // footer centered
          ctx.fillStyle = 'rgba(255,255,255,0.92)';
          ctx.font = Math.max(10, Math.round(final.width*0.012)) + 'px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Feito com ❤️ por Everton Tezzon Ferreira', final.width / 2, final.height - 12);
          ctx.textAlign = 'left';

          // download
          final.toBlob(function(blob){
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'SafeTurn_map.png';
            document.body.appendChild(a); a.click(); a.remove();
            setTimeout(()=> URL.revokeObjectURL(url), 1500);
          }, 'image/png');

          resolve();
        } catch(drawErr){
          reject(drawErr);
        }
      });
    });
  } catch(e){
    console.warn('capture failed, fallback vector-only drawing', e);
    try{
      // fallback: draw minimal vector version matching layout
      const size = map.getSize();
      const final = document.createElement('canvas');
      final.width = size.x; final.height = size.y;
      const ctx = final.getContext('2d');

      // simple background
      ctx.fillStyle = '#e9eef2'; ctx.fillRect(0,0,final.width,final.height);

      // draw track and points (if present)
      if(track && track.length){
        ctx.strokeStyle = 'red'; ctx.lineWidth = 4; ctx.beginPath();
        for(let i=0;i<track.length;i++){
          const pt = map.latLngToContainerPoint([track[i].lat, track[i].lng]);
          if(i===0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
      }
      if(points && points.length === 3){
        ctx.setLineDash([8,6]); ctx.strokeStyle = '#8e44ad'; ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i=0;i<3;i++){
          const pt = map.latLngToContainerPoint(points[i]);
          if(i===0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke(); ctx.setLineDash([]);
        const end = map.latLngToContainerPoint(points[2]);
        ctx.fillStyle = '#8e44ad'; ctx.beginPath(); ctx.moveTo(end.x, end.y); ctx.lineTo(end.x-14, end.y-16); ctx.lineTo(end.x+14, end.y-16); ctx.closePath(); ctx.fill();
        for(let i=0;i<3;i++){
          const m = map.latLngToContainerPoint(points[i]);
          ctx.fillStyle = (i===1? '#f1c40f' : (i===0? '#2ecc71' : '#3498db'));
          ctx.beginPath(); ctx.arc(m.x, m.y, 6, 0, Math.PI*2); ctx.fill();
        }
      }

      // app title top-left
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(10,10,110,34);
      ctx.fillStyle = '#fff'; ctx.font = '18px sans-serif'; ctx.fillText('Safe Turn', 18, 34);

      // centered box above footer
      const boxW = Math.min(final.width - 40, Math.max(260, Math.round(final.width * 0.6)));
      const boxH = Math.round(final.height * 0.12);
      const boxX = (final.width - boxW) / 2;
      const boxY = final.height - boxH - 36;
      ctx.fillStyle = 'rgba(255,255,255,0.96)'; roundRect(ctx, boxX, boxY, boxW, boxH, 12, true, false);
      ctx.fillStyle = '#111'; ctx.textAlign = 'center';
      // if we have geom values show them, else placeholders
      const cLat = geom && geom.center ? geom.center.lat.toFixed(6) : '-';
      const cLng = geom && geom.center ? geom.center.lng.toFixed(6) : '-';
      const R = geom ? geom.R.toFixed(2) : '-';
      const d = geom ? geom.deltaDeg.toFixed(2) : '-';
      ctx.font = '14px sans-serif';
      ctx.fillText(`${cLat} - ${cLng}`, final.width/2, boxY + Math.round(boxH*0.43));
      ctx.fillText(`${R} m  -  ${d}°`, final.width/2, boxY + Math.round(boxH*0.78));
      ctx.textAlign = 'left';

      // footer
      ctx.fillStyle = 'rgba(255,255,255,0.92)'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('Feito com ❤️ por Everton Tezzon Ferreira', final.width / 2, final.height - 12);
      ctx.textAlign = 'left';

      final.toBlob(function(blob){
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'SafeTurn_map_fallback.png';
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=> URL.revokeObjectURL(url), 1500);
      }, 'image/png');

    } catch(err){
      alert('Erro ao gerar imagem: ' + (err && err.message ? err.message : err));
    }
  }
});

/* helper to draw rounded rectangle */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* init overlay defaults */
setOverlayLines(null, null, null, 'Aguardando 3 pontos ou gravação');

/* expose for debug */
window.SafeTurn = { calcularGeometria };

</script>
</body>
</html>